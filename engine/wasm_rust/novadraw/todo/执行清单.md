# Novadraw 执行清单

## 项目目标

实现类似 Eclipse Draw2D 的矢量图绘图引擎，基于 WebGPU 技术栈，支持 macOS、Windows、Web 平台。

## Eclipse Draw2D 核心原理

- **Figure 系统**：所有图形对象的基类，支持层次化结构
- **Lightweight 图形**：不依赖原生窗口，纯软件渲染
- **变换栈**：支持坐标变换（平移、旋转、缩放）
- **区域计算**：Clip、Intersection、Union 等操作
- **事件处理**：鼠标、键盘事件和命中测试
- **布局管理器**：FlowLayout、BorderLayout 等

---

## 阶段一：核心框架搭建 ✅ 已完成

### 1.1 基础架构

- [x] 项目结构设计（novadraw crate + apps 应用层）
- [x] 场景图管理（SceneGraph、RuntimeBlock）
- [x] BlockId 高速索引 + UUID 持久化双索引设计
- [x] Paint Trait 定义（可扩展图形接口）
- [x] RectangleFigure 实现

### 1.2 渲染抽象层

- [x] RenderCommand IR（渲染中间表示）
- [x] RenderContext（命令收集）
- [x] VelloRenderer 实现（基于 wgpu/WebGPU）
- [x] 应用层与渲染层解耦

### 1.3 应用入口

- [x] winit 窗口管理
- [x] 事件循环
- [x] SceneManager 场景图管理
- [x] 基础 demo（显示矩形）

---

## 阶段二：Figure 系统扩展 ⭐

### 设计原则：分层架构

```
┌─────────────────────────────────────────────────────────┐
│  Figure 层（独立类型，类型安全）                          │
│  RectangleFigure | EllipseFigure | PathFigure ...      │
│                        │                                 │
│                        │ to_render_command()            │
│                        ▼                                 │
┌─────────────────────────────────────────────────────────┐
│  RenderCommand 层（统一 IR，解耦渲染器）                  │
│  RenderCommand::Fill | Stroke | Path                    │
└─────────────────────────────────────────────────────────┘
```

**核心思想**：

- 每个 Figure 独立实现，保持类型安全和 API 友好
- 渲染时统一转换为 RenderCommand
- 支持未来替换渲染器实现

### 2.1 基础 Figure（独立类型）

- [x] RectangleFigure（矩形）- ✅ 已有
- [ ] EllipseFigure（椭圆）- 独立类型
- [ ] CircleFigure（圆形）- 独立类型
- [ ] LineFigure（直线）- 独立类型
- [ ] PolygonFigure（多边形）- 独立类型

### 2.2 路径 Figure

- [ ] PathFigure（贝塞尔路径）
  - 直线命令（MoveTo, LineTo）
  - 曲线命令（Bezier, Quadratic）
  - 填充规则（非零/奇偶）
  - 描边支持（Stroke）
  - 使用 kurbo 进行数学计算

### 2.3 组合 Figure

- [ ] RootFigure（根图形，透明背景）
- [ ] FigureGroup（图形组）

### 2.4 图形属性

- [ ] 边框（Stroke）属性：宽度、颜色、线型
- [ ] 填充（Fill）属性：纯色、渐变
- [ ] 阴影（Shadow）效果 - 后期实现

### 2.5 Paint Trait 统一接口

```rust
pub trait Paint {
    fn paint(&self, ctx: &mut RenderContext);  // 绘制到 RenderContext
    fn bounding_box(&self) -> Rect;            // 边界盒（用于裁剪）
    // 可选：fn to_render_command(&self) -> RenderCommand;
}
```

---

## 阶段三：无限画布架构 ⭐ 核心目标

### 3.1 无限坐标系统

- [ ] 双精度浮点坐标（f64），提供理论无限精度
- [ ] 世界坐标 ↔ 屏幕坐标转换矩阵
- [ ] 视口（Viewport）管理
- [ ] 缩放系数（Zoom）无硬性上限，由 LOD 自动适配
- [ ] 平移偏移（Pan Offset）
- [ ] 坐标变换栈

```
┌─────────────────────────────────────────────────────────────┐
│                    无限画布坐标系                            │
│                                                             │
│   世界坐标 (World)          视口坐标 (Viewport)              │
│   ────────────────  ────────────────────────────────────    │
│   无边界限制          →   当前可见区域                       │
│   f64 精度            →   屏幕像素映射                       │
│                                                             │
│   变换公式: screen_pos = (world_pos - pan) * zoom           │
│                                                             │
│   核心原理:                                                  │
│   - f64 世界坐标可表示 ±1.7e308 范围                        │
│   - 渲染时通过 LOD 策略适配不同缩放级别                      │
│   - 极高缩放时用 Tile 纹理替代矢量渲染                      │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 视口管理

- [ ] Viewport 结构（x, y, width, height, zoom）
- [ ] 视口约束（不是硬限制，而是 LOD 切换阈值）
- [ ] 视口动画（平滑缩放/平移）
- [ ] 视口同步（多视图联动）

### 3.3 空间索引 ⭐ 核心优化

**为什么需要？**
- 无限画布可能有百万级图形
- 每次渲染/命中测试不能遍历所有图形
- 需要 O(log n) 而不是 O(n) 的查找

**推荐方案：QuadTree**

```
┌─────────────────────────────────────────┐
│              Root (0,0, ∞, ∞)            │
│  ┌─────────────────┬─────────────────┐  │
│  │ NW              │ NE              │  │
│  │  (-∞,0)-(0,∞)   │  (0,0)-(∞,∞)    │  │
│  └─────────────────┴─────────────────┘  │
│  ┌─────────────────┬─────────────────┐  │
│  │ SW              │ SE              │  │
│  │  (-∞,-∞)-(0,0)  │  (0,-∞)-(∞,0)   │  │
│  └─────────────────┴─────────────────┘  │
└─────────────────────────────────────────┘

- 递归划分 4 个子区域
- 节点容量满时分裂（通常 8~16 个图形）
- 支持范围查询、点查询
```

- [ ] QuadTree 实现
- [ ] 插入/删除/更新
- [ ] 范围查询（视口内图形）
- [ ] 点查询（命中测试）
- [ ] 与 SceneGraph 集成

### 3.4 增量渲染 ⭐ 性能关键

**为什么需要？**
- 无限画布内容可能很多
- 每次全量重绘太慢
- 只重绘"脏"区域

```
┌─────────────────────────────────────────────┐
│              增量渲染流程                    │
│                                             │
│  1. 标记脏区域 (dirty rects)                 │
│     - 图形移动/缩放                          │
│     - 新增/删除图形                          │
│     - 视口变化                               │
│                                             │
│  2. 计算合并脏区域                            │
│     - 合并重叠矩形                           │
│     - 限制最大脏区域数量                     │
│                                             │
│  3. 只渲染脏区域                             │
│     - 与视口裁剪结合                         │
│     - 减少 GPU draw calls                   │
└─────────────────────────────────────────────┘
```

- [ ] 脏矩形跟踪（Dirty Rect Tracking）
- [ ] 矩形合并算法
- [ ] 增量 scene 更新
- [ ] 与 Vello 集成

### 3.5 LOD 细节层次 ⭐ 核心优化

**为什么需要？**
- 缩放极小时，图形细节不可见
- 缩放极大时，GPU 渲染精度受限（f32）
- 需要在不同缩放级别采用不同渲染策略

**无限缩放原理**

```
┌─────────────────────────────────────────────────────────────┐
│                    LOD 渲染策略                              │
├─────────────────────────────────────────────────────────────┤
│  zoom > 1000x     预渲染纹理（Tile Cache）                   │
│                   极高缩放时，用高精度位图替代矢量            │
├─────────────────────────────────────────────────────────────┤
│  100x < zoom ≤ 1000x                                        │
│                   GPU 坐标归一化 + 纹理缓存                   │
│                   保持精度，避免渲染闪烁                      │
├─────────────────────────────────────────────────────────────┤
│  0.01x < zoom ≤ 100x  完整矢量渲染（正常工作区间）           │
│                   此时 f32/f64 精度都足够                    │
├─────────────────────────────────────────────────────────────┤
│  zoom ≤ 0.01x      简化渲染                                  │
│                   只渲染包围盒、占位符                        │
│                   极小缩放时无需绘制细节                      │
└─────────────────────────────────────────────────────────────┘
```

**无限放大的关键**：

1. **f64 世界坐标**：提供理论无限精度
2. **GPU 坐标归一化**：渲染时将世界坐标映射到 f32 精度范围
3. **Tile 纹理缓存**：极高缩放时，缓存局部区域的高精度纹理
4. **无缝切换**：当 zoom 超过阈值时，自动从矢量渲染切换到纹理渲染

```
世界坐标 (f64)          视口变换                    屏幕渲染
    │                      │                          │
    ▼                      ▼                          ▼
 (x: 1.5e100)       ──►  归一化到 [-1,1]       ──►  GPU 渲染
    │                      │                          │
    │                      ▼                          ▼
    │               极高缩放时：              使用 Tile 缓存
    │               从 Tile 缓存读取                │
    └────────────────────────────────────────────────────────
```

- [ ] LOD 计算器（根据 zoom 计算渲染策略）
- [ ] 图形简化策略（小缩放时简化，大缩放时保持精度）
- [ ] Tile 纹理缓存系统（极高缩放时使用位图替代矢量）
- [ ] GPU 坐标归一化（避免 f32 精度丢失）
- [ ] 无缝切换机制（矢量 ↔ 纹理自动切换）

---

## 阶段五：变换与坐标系统

### 5.1 变换接口

- [ ] Transform Trait（变换接口）
- [ ] IdentityTransform（恒等变换）
- [ ] TranslationTransform（平移）
- [ ] ScaleTransform（缩放）
- [ ] RotationTransform（旋转）
- [ ] AffineTransform（仿射变换，使用 glam）

### 5.2 坐标系统

- [ ] 本地坐标 → 父坐标 → 世界坐标转换
- [ ] 坐标变换栈
- [ ] InverseTransform（逆变换，用于事件映射）

---

## 阶段六：区域与裁剪（后期优化）

### 4.1 区域计算

- [ ] Region 数据结构（基于 kurbo Region）
- [ ] Intersection（交集）
- [ ] Union（并集）
- [ ] Subtract（差集）
- [ ] ExclusiveOr（异或）
- [ ] IsEmpty、Contains、Equals

### 4.2 裁剪优化

- [ ] 基于区域的可见性裁剪
- [ ] 脏矩形（Dirty Rect）跟踪
- [ ] 增量渲染

---

## 阶段八：事件处理与命中测试 ⭐ P0

### 5.1 事件系统

- [ ] MouseEvent（鼠标事件）
- [ ] KeyboardEvent（键盘事件）
- [ ] FocusEvent（焦点事件）
- [ ] EventTarget（事件目标）
- [ ] EventDispatcher（事件分发）

### 5.2 命中测试

- [ ] HitTest 策略
- [ ] 图形边界命中
- [ ] 图形内部命中
- [ ] 透明度阈值控制
- [ ] 层级优先顺序

### 5.3 交互状态

- [ ] Selection（选择）
- [ ] Focus（焦点）
- [ ] Hover（悬停）
- [ ] Dragging（拖拽）
- [ ] Resizing（调整大小）

---

## 阶段十：布局管理器

### 6.1 基础布局

- [ ] LayoutManager Trait
- [ ] FlowLayout（流式布局）
- [ ] BorderLayout（边界布局）
- [ ] GridLayout（网格布局）
- [ ] StackLayout（栈式布局）

### 6.2 高级布局

- [ ] Constraint（约束）
- [ ] LayoutContainer（布局容器）
- [ ] LayoutNode（布局节点）
- [ ] PreferredSize（首选尺寸）

---

## 阶段十一：高级图形特性

### 7.1 渐变与效果

- [ ] LinearGradient（线性渐变）
- [ ] RadialGradient（径向渐变）
- [ ] BlurEffect（模糊效果）
- [ ] GlowEffect（发光效果）

### 7.2 文本支持

- [ ] TextFigure（文本图形）
- [ ] Font（字体）
- [ ] TextLayout（文本布局）
- [ ] RichText（富文本）

### 7.3 图像支持

- [ ] ImageFigure（图像图形）
- [ ] SVGFigure（SVG 导入）
- [ ] 图像缓存

---

## 阶段十二：WebGPU 跨平台渲染架构 ⭐ 重点

### 8.1 统一渲染架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Novadraw 核心引擎                          │
│  ┌─────────────┐  RenderCommand IR  ┌─────────────────────┐ │
│  │   Figure    │ ──────────────────►│  RenderContext      │ │
│  │   System    │                    └──────────┬──────────┘ │
│  └─────────────┘                              │             │
└───────────────────────────────────────────────┼─────────────┘
                                                │
                                                ▼
┌─────────────────────────────────────────────────────────────┐
│                      渲染器实现                               │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  VelloRenderer (当前实现)                                ││
│  │  - 基于 wgpu/vello                                       ││
│  │  - 支持路径、渐变、混合模式                               ││
│  │  - 未来可替换为自研渲染引擎                               ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                      wgpu/WebGPU 抽象层                       │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐ │
│  │ Metal (macOS)    │  │ D3D12 (Windows)  │  │ WebGPU (Web) │ │
│  └──────────────────┘  └──────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 8.2 WebGPU 核心配置

- [ ] wgpu 0.19+ 配置（支持 WebGPU 标准）
- [ ] WebGPU 设备初始化
- [ ] CommandEncoder 管理
- [ ] RenderPipeline 配置
- [ ] Shader Module 加载

### 8.3 VelloRenderer 完善（基于 WebGPU）

- [ ] 完整实现 Scene → RenderCommand 转换
- [ ] 批处理优化
- [ ] 异步渲染支持

### 8.4 Web 端专用模块

- [ ] web-sys 集成（HTMLCanvasElement）
- [ ] winit-web 窗口适配
- [ ] JavaScript 互操作（wasm-bindgen）
- [ ] RequestAnimationFrame 循环
- [ ] WebWorker 多线程渲染（OffscreenCanvas）

---

## 阶段十三：桌面端跨平台（基于 wgpu）

### 9.1 winit + wgpu 集成

- [ ] 窗口与设备绑定
- [ ] Surface 配置
- [ ] 帧同步（PresentMode）

### 9.2 平台后端

- [ ] Metal 后端（macOS，自动选择）
- [ ] D3D12 后端（Windows，自动选择）
- [ ] Vulkan 后端（Linux，可选）
- [ ] OpenGL ES 后端（备用，兼容老设备）

### 9.3 平台特定优化

- [ ] macOS：Metal 性能优化
- [ ] Windows：D3D12 资源管理
- [ ] Linux：Vulkan 验证层

---

## 阶段十四：编辑器功能

### 10.1 工具系统

- [ ] ToolManager（工具管理）
- [ ] SelectionTool（选择工具）
- [ ] RectangleTool（矩形工具）
- [ ] EllipseTool（椭圆工具）
- [ ] LineTool（直线工具）
- [ ] PenTool（钢笔工具）
- [ ] TextTool（文本工具）
- [ ] PanTool（平移工具）
- [ ] ZoomTool（缩放工具）

### 10.2 操作命令

- [ ] Command Pattern（命令模式）
- [ ] CreateCommand（创建命令）
- [ ] DeleteCommand（删除命令）
- [ ] MoveCommand（移动命令）
- [ ] ResizeCommand（调整大小命令）
- [ ] ChangePropertyCommand（属性修改命令）
- [ ] Undo/Redo（撤销/重做）

### 10.3 属性面板

- [ ] PropertySheet（属性面板）
- [ ] 颜色选择器
- [ ] 字体选择器
- [ ] 变换控制柄

---

## 阶段十五：性能优化

### 11.1 WebGPU 特定优化

- [ ] GPU 命令批处理
- [ ] 管线状态对象（PSO）缓存
- [ ] 纹理绑定组重用
- [ ] 异步着色器编译
- [ ] 帧时间预算控制

### 11.2 渲染优化

- [ ] 图层缓存
- [ ] 视口剔除
- [ ] 多线程渲染（桌面端）
- [ ] 增量更新

### 11.3 内存优化

- [ ] 对象池
- [ ] GPU 资源管理
- [ ] 懒加载

---

## 阶段十六：文件格式

### 12.1 导入导出

- [ ] JSON 格式（当前内部格式）
- [ ] SVG 导出
- [ ] PNG/JPEG 导出（使用 image crate）
- [ ] PDF 导出

---

## 阶段十七：测试与文档

### 13.1 单元测试

- [ ] Figure 测试
- [ ] 变换测试
- [ ] 区域计算测试
- [ ] 布局测试

### 13.2 集成测试

- [ ] 渲染结果测试
- [ ] 事件处理测试
- [ ] 跨平台测试

### 13.3 文档

- [ ] API 文档（docs.rs）
- [ ] 用户指南
- [ ] 示例代码

---

## 目录结构

```
novadraw/
├── Cargo.toml
├── novadraw/                       # 核心引擎
│   ├── src/
│   │   ├── lib.rs
│   │   ├── block.rs                # RuntimeBlock, SceneGraph
│   │   ├── figure/                 # Figure 系统
│   │   │   ├── mod.rs
│   │   │   ├── basic.rs            # 基础图形
│   │   │   ├── path.rs             # 路径图形
│   │   │   └── text.rs             # 文本图形
│   │   ├── transform.rs            # 变换系统
│   │   ├── region.rs               # 区域计算
│   │   ├── event.rs                # 事件系统
│   │   ├── layout.rs               # 布局系统
│   │   ├── render_ir.rs            # 渲染 IR
│   │   ├── render_ctx.rs           # 渲染上下文
│   │   ├── color.rs                # 颜色
│   │   ├── renderer/               # 渲染器模块 ⭐
│   │   │   ├── mod.rs              # VelloRenderer
│   │   │   └── vello.rs            # Vello 实现
│   │   └── wgpu/                   # wgpu/WebGPU 包装
│   │       └── mod.rs
│   └── Cargo.toml
├── apps/
│   ├── editor/                     # 桌面编辑器
│   │   ├── src/
│   │   │   ├── main.rs
│   │   │   ├── app_window.rs       # winit 窗口
│   │   │   ├── scene_manager.rs
│   │   │   ├── tool_manager.rs
│   │   │   └── ui/                 # UI 组件
│   │   ├── build.rs                # 资源构建
│   │   └── Cargo.toml              # target = "wasm32-unknown-unknown" 禁用
│   └── web/                        # Web 版本 ⭐
│       ├── src/
│       │   ├── lib.rs              # WASM 入口
│       │   ├── canvas.rs           # Canvas 绑定
│       │   ├── app.rs              # Web 应用
│       │   └── bindings.rs         # JS 互操作
│       ├── index.html
│       ├── build.rs                # wasm-pack 配置
│       ├── Cargo.toml              # target = "wasm32-unknown-unknown"
│       └── www/                    # 前端打包
│           ├── package.json
│           └── vite.config.ts
└── todo/
    └── 执行清单.md                  # 本文件
```

---

## 技术选型说明 ⭐ 重要

### 短期策略（当前阶段）

使用 **vello** 作为渲染后端，快速开发验证产品。

- vello 基于 wgpu，提供高质量 2D 渲染
- 支持路径、光栅化、混合模式
- 学习 vello 的架构和渲染原理

### 长期策略（自研目标）

当架构稳定后，逐步替换为自研渲染引擎。

- 渲染抽象层（RenderCommand IR）已就绪，支持平滑迁移
- 文字渲染引擎独立开发（Glyph 缓存 + GPU 渲染）
- 路径渲染自研（stroke、fill GPU 着色器）
- 目标：完全自主可控的渲染技术栈

### 迁移路径

```
当前架构                    迁移后架构
--------                   --------
Figure → RenderCommand → VelloRenderer → wgpu
                        ↓
                        替换为自研渲染器
                        ↓
Figure → RenderCommand → 自研Renderer → wgpu
```

**迁移时只需替换渲染器实现，Figure 系统和 RenderCommand IR 保持不变。**

---

## 技术选型 ⭐ WebGPU 统一架构

| 模块        | 技术选型                        | 备注                         |
| ----------- | ------------------------------- | ---------------------------- |
| 窗口管理    | winit                           | 桌面端原生，Web 端用 web-sys |
| 渲染引擎    | **wgpu**                        | 统一 API，跨桌面+WebGPU      |
| 矢量渲染    | **vello**                       | 基于 wgpu，高性能 2D（短期） |
| 数学库      | glam                            | SIMD 优化                    |
| 序列化      | serde                           | JSON/二进制                  |
| WebAssembly | wasm-bindgen + wasm-pack        |                              |
| 前端构建    | Vite + TypeScript               |                              |
| 平台后端    | Metal/D3D12/Vulkan + **WebGPU** | 统一抽象                     |

### WebGPU 优势

- **跨平台统一**：桌面端和 Web 端使用相同 API
- **高性能**：GPU 计算着色器
- **低延迟**：实时渲染
- **现代特性**：光追、降采样等

---

## 优先级排序

### 高优先级（P0）

1. ✅ 核心框架搭建
2. ✅ 事件与命中测试 - ⭐ 提前，编辑器交互核心
3. ✅ 分层 Figure 架构 - 独立 Figure + 统一 RenderCommand
4. 变换系统（平移、缩放、旋转）
5. 基础 Figure（Ellipse, Circle, Line, Polygon）

### 中优先级（P1）

1. PathFigure（贝塞尔路径）
2. 布局管理器
3. ✅ 工具系统（Select/Rectangle/Circle）
4. Undo/Redo

### 低优先级（P2）

1. 高级效果（渐变、阴影）
2. 文本支持
3. 图像支持
4. SVG/PDF 导出

---

## 启动建议

1. **阶段一已完成**，验证架构可行性
2. **阶段五（事件系统）提前到 P0**，编辑器必须有交互能力
3. **阶段二 + 阶段三并行**，Figure 和变换是渲染基础
4. **阶段八 WebGPU** 优先，因为要统一架构
5. **Web 版本**可与桌面版并行开发，共享核心引擎

**里程碑规划**：

- M1: 静态渲染（✅ 已完成）
- M2: 鼠标悬停高亮（事件 + 命中测试）（✅ 已完成）
- M3: 图形选择与拖拽（变换系统）（✅ 已完成）
- M4: 绘制新图形（工具系统）（✅ 已完成）
- M5: 框选功能（✅ 已完成）
- M6: 变换系统完善（平移、缩放、旋转）
- M7: 椭圆/圆形工具
- M8: 路径绘制工具
- M9: 无限画布（视口、缩放、平移）
- M10: 空间索引（QuadTree）
- M11: 增量渲染（脏矩形）
- M12: LOD 细节层次

---

## Web 开发快速开始

```bash
# 安装 wasm-pack
cargo install wasm-pack

# 构建 Web 版本
cd novadraw/apps/web
wasm-pack build --target web

# 开发模式
cd novadraw/apps/web/www
npm install
npm run dev
```

---

## 关键依赖版本

```toml
[dependencies]
wgpu = "0.19"           # WebGPU 支持
vello = "0.5"           # 2D 渲染
winit = "0.30"          # 窗口管理
glam = "0.25"           # 数学库
serde = { version = "1.0", features = ["derive"] }
wasm-bindgen = "0.2"    # WebAssembly
web-sys = "0.3"         # Web API

[target.'cfg(target_arch = "wasm32")'.dependencies]
wgpu = "0.19"           # WebGPU on Web
```

---

## 风险与应对

| 风险             | 应对措施              |
| ---------------- | --------------------- |
| WebGPU 兼容性    | 提供 Canvas 2D 回退   |
| macOS Metal 差异 | wgpu 自动处理后端选择 |
| 性能问题         | 增量渲染 + 图层缓存   |
| 学习曲线         | 分离核心与平台代码    |
