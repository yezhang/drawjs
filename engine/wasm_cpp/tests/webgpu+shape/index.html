<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>关键数据结构验证</title>
    <link href="css/style.css" rel="stylesheet" />
  </head>
  <body>
    <canvas id="unlimit_canvas" width="100%" height="100%"></canvas>
    <script type="module">
      try {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("WebGPU adapter not available");
        }

        const device = await adapter.requestDevice();
        const preferredFormat = navigator.gpu.getPreferredCanvasFormat();
        const canvas = document.getElementById("unlimit_canvas");
        const ctx = canvas.getContext("webgpu");

        if (!ctx) {
          throw new Error("WebGPU context not available");
        }

        ctx.configure({
          device: device,
          format: preferredFormat,
        });
      } catch (error) {
        console.error("Error initializing WebGPU:", error);
        alert("WebGPU initialization failed: " + error.message);
      }
      let isDrawing = false;
      let startX, startY;
      let currentX, currentY;

      // Create a buffer for rectangle vertices
      const vertexBuffer = device.createBuffer({
        size: 4 * 4 * 4, // 4 vertices * 4 floats (x,y,z,w) * 4 bytes
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      });

      // Create a render pipeline
      const pipeline = device.createRenderPipeline({
        vertex: {
          module: device.createShaderModule({
            code: `
              struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) color: vec4<f32>,
              };

              @vertex
              fn main(@location(0) position: vec4<f32>) -> VertexOutput {
                var output: VertexOutput;
                output.position = position;
                output.color = vec4(0.0, 0.0, 1.0, 1.0); // Blue color
                return output;
              }
            `,
          }),
          entryPoint: "main",
          buffers: [
            {
              arrayStride: 4 * 4, // 4 floats * 4 bytes
              attributes: [
                {
                  shaderLocation: 0,
                  offset: 0,
                  format: "float32x4",
                },
              ],
            },
          ],
        },
        fragment: {
          module: device.createShaderModule({
            code: `
              @fragment
              fn main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {
                return color;
              }
            `,
          }),
          entryPoint: "main",
          targets: [
            {
              format: preferredFormat,
            },
          ],
        },
        primitive: {
          topology: "triangle-strip",
        },
      });

      canvas.addEventListener("mousedown", (e) => {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        startX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        startY = (-(e.clientY - rect.top) / rect.height) * 2 + 1;
        currentX = startX;
        currentY = startY;
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDrawing) {
          const rect = canvas.getBoundingClientRect();
          currentX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          currentY = (-(e.clientY - rect.top) / rect.height) * 2 + 1;
          drawRect();
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDrawing = false;
      });

      canvas.addEventListener("mouseleave", () => {
        isDrawing = false;
      });

      function drawRect() {
        // Calculate rectangle vertices in clip space
        const vertices = new Float32Array([
          startX,
          startY,
          0.0,
          1.0,
          currentX,
          startY,
          0.0,
          1.0,
          startX,
          currentY,
          0.0,
          1.0,
          currentX,
          currentY,
          0.0,
          1.0,
        ]);

        // Update vertex buffer
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        // Create command encoder
        const commandEncoder = device.createCommandEncoder();
        const textureView = ctx.getCurrentTexture().createView();

        const renderPassDescriptor = {
          colorAttachments: [
            {
              view: textureView,
              clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        };

        const passEncoder =
          commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setPipeline(pipeline);
        passEncoder.setVertexBuffer(0, vertexBuffer);
        passEncoder.draw(4);
        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);
      }
    </script>
  </body>
</html>
